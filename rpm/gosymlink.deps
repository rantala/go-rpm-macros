#!/bin/bash
# Copyright Â© 2018 Nicolas Mailhot <nim@fedoraproject.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

usage() {
cat >&2 << EOF_USAGE
Usage: $0 <action> [ [-h] ]
                   [ [-p <prefix>] [-g <go path>] ]

<action>             should be one of: provides, requires

Most actions accept the same set of arguments, and will silently ignore those
that do not apply to a specific action. Unless specified otherwise, all
arguments are optional.

Common arguments:

-h                   print this help
-p <prefix>:         an optionnal prefix path such as %{buildroot}
-g <go path>:        the root of the Go source tree
                     default value if not set: /usr/share/gocode
EOF_USAGE
exit 1
}

action=''
version=''
prefix=''
gopath=/usr/share/gocode

if [[ $# -eq 0 ]] ; then
  usage
else case $1 in
    provides|requires) action=$1 ;;
    *)                 usage ;;
  esac
fi

shift

if ! options=$(getopt -n $0 -o hp:gv:a: \
                      -l help,prefix:,go-path: \
                      -l version:,attribute: \
                      -- "$@")
then
    usage
fi

eval set -- "$options"

while [ $# -gt 0 ] ; do
  case $1 in
    -h|--help)                      usage ;;
    -p|--prefix)                    prefix=$(realpath -sm "$2")  ; shift;;
    -g|--go-path)                   gopath="$2"                  ; shift;;
    (--)          shift; break;;
    (-*)          usage ;;
    (*)           break;;
  esac
  shift
done

# Convert paths within gopath to version-constrained provides
provides() {
local p="golang(${1#${prefix}${gopath}/src/})"
echo "${p}${metadata[version]:+ = ${metadata[version]}}"
for m in "${!metadata[@]}" ; do
  if [[ "${m}" != "version" ]] ; then
    echo "${p}(${m}=${metadata[${m}]})${metadata[version]:+ = ${metadata[version]}}"
  fi
done
}

# Convert paths within gopath to version-constrained provides
requires() {
local r="golang(${1#${prefix}${gopath}/src/})"
echo "${r}${metadata[version]:+ = ${metadata[version]}}"
}

# Resolve a symlink target in presence of a build root
resolvelink() {
  local lt=$(realpath -m "$1")
  echo "${prefix}${lt#${prefix}}"
}

# Resolve a symlink to its ultimate target in presence of a build root
ultimateresolvelink() {
  local lt="$1"
  until [[ ! -L ${lt} ]] ; do
    lt=$(resolvelink "${lt}")
  done
  echo "${lt}"
}

# Test if a path is a directory within the target gopath
isgopathdir() {
  local lt="$1"
  if [[ -d ${lt} ]] && [[ "${lt}"/ == "${prefix}${gopath}"/src/* ]] ; then
    true
  else
    false
  fi
}

# Read version info stored in .goipath
readmetadata() {
  medadatafile="${1}"
  unset metadata
  declare -g -A metadata
  for m in version tag commit branch ; do
    v=$(grep "^${m}\:" "${medadatafile}" | head -1)
    v="${v#${m}:}"
    [[ -n "${v}" ]] && metadata["${m}"]="${v}"
  done
}

# Find the best .goipath match and load it
findlockdir() {
  local lt="$1"
  while [[ "${lt}" != "${prefix}${gopath}/src" && ! -e "${lt}/.goipath" ]] ; do
    lt=$(dirname ${lt})
  done
  [[ -e "${lt}/.goipath" ]] && echo "${lt}" || :
}

# A symlink can point to a whole directory tree, but go.attr will only
# trigger on the root symlink.
# Therefore, check the symlink points within the processed import path, then
# walk all the target tree to generate symlink provides/requires
#
# To process nested symlinks the function needs to be provided a working path
# to the symlink tip within the build root as second argument.
processlink() {
  local link="$1"
  local nexttarget=$(resolvelink "$2")
  local linktarget=$(ultimateresolvelink "${nexttarget}")
  if isgopathdir "${linktarget}" ; then
    local lockdir=$(findlockdir "${linktarget}")
    [[ -e "${lockdir}/.goipath" ]] && readmetadata "${lockdir}/.goipath"
    case ${action} in
      provides) find "${linktarget}" -type d -print | while read subdir ; do
                  provides    "${link}${subdir#${linktarget}}"
                done
                find "${linktarget}" -type l -print | while read sublink ; do
                  processlink "${link}${sublink#${linktarget}}" "${sublink}"
                done ;;
      requires) requires "${lockdir}" ;;
    esac
  fi
}

# go.attr ensures that every time a package declares owning a symlink under
# %{gopath}/src, symlink name will be piped to this script to compute the
# package Go provides/requires.
#
# For legacy reason the script is supposed to be able to handle multiple
# inputs, even though modern rpm invokes it separately for each directory.
while read dir ; do
  if [[ -L $dir ]] ; then
    processlink "$dir" "$dir"
  fi
done | sort -u | grep -v '/\([._]\)\?\(internal\|testdata\|vendor\)\([/)]\)'
